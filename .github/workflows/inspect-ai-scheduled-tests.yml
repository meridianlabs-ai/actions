---
name: Inspect AI Scheduled Tests

"on":
  schedule:
    # Run daily at 2 AM UTC
    - cron: "0 2 * * *"
  push:
    branches:
      - "**" # Run on all branches for testing
    # TODO: Comment out the push trigger before merging to main
    # This is only used during action development cycle
  workflow_dispatch:
    inputs:
      run_slow_tests:
        description: "Run slow tests"
        required: false
        default: true
        type: boolean
      run_api_tests:
        description: "Run API tests (requires secrets)"
        required: false
        default: false
        type: boolean

jobs:
  slow-tests:
    if: ${{ github.event_name == 'schedule' || github.event_name == 'push' || inputs.run_slow_tests }}
    runs-on: ubuntu-latest

    steps:
      # Critical: Setup modern Docker build system
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          version: latest
          driver-opts: |
            network=host
          buildkitd-flags: |
            --allow-insecure-entitlement security.insecure
            --allow-insecure-entitlement network.host

      # Verify Docker is working before running tests
      - name: Verify Docker functionality
        run: |
          docker --version
          docker info
          docker buildx version
          docker run --rm hello-world
          echo "âœ… Docker is properly configured"

      - name: Checkout inspect_ai repository
        uses: actions/checkout@v4
        with:
          repository: UKGovernmentBEIS/inspect_ai

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # Install inspect_ai with development dependencies for testing
          pip install -e ".[dev]"

      - name: Create Docker test script
        run: |
          cat > test_docker.py << 'EOF'
          def test_docker_environment():
              """Verify Docker environment before running real tests"""
              import subprocess
              import time
              
              print("Testing Docker environment...")
              
              # Test basic Docker functionality
              print("1. Testing docker --version...")
              result = subprocess.run(['docker', '--version'], 
                                    capture_output=True, text=True, timeout=10)
              print(f"   Return code: {result.returncode}")
              print(f"   Output: {result.stdout.strip()}")
              assert result.returncode == 0
              
              # Test Docker daemon is responsive
              print("2. Testing docker info...")
              result = subprocess.run(['docker', 'info'], 
                                    capture_output=True, text=True, timeout=10)
              print(f"   Return code: {result.returncode}")
              print(f"   First few lines: {result.stdout[:200]}...")
              assert result.returncode == 0
              
              # Test basic container execution
              print("3. Testing basic container run...")
              start_time = time.time()
              result = subprocess.run(['docker', 'run', '--rm', 'python:3.12-bookworm', 'echo', 'hello'], 
                                    capture_output=True, text=True, timeout=30)
              duration = time.time() - start_time
              print(f"   Return code: {result.returncode}")
              print(f"   Output: {result.stdout.strip()}")
              print(f"   Duration: {duration:.2f} seconds")
              assert result.returncode == 0
              assert 'hello' in result.stdout
              
              # Test Docker build (similar to what inspect_ai does)
              print("4. Testing Docker build...")
              dockerfile_content = '''FROM python:3.12-bookworm
          RUN echo "test build"
          CMD echo "container started"
          '''
              with open('Dockerfile.test', 'w') as f:
                  f.write(dockerfile_content)
              
              start_time = time.time()
              result = subprocess.run(['docker', 'build', '-t', 'test-image', '-f', 'Dockerfile.test', '.'], 
                                    capture_output=True, text=True, timeout=60)
              duration = time.time() - start_time
              print(f"   Build return code: {result.returncode}")
              print(f"   Build duration: {duration:.2f} seconds")
              print(f"   Build output (last 500 chars): ...{result.stdout[-500:]}")
              assert result.returncode == 0
              
              # Test running the built image
              print("5. Testing running built container...")
              start_time = time.time()
              result = subprocess.run(['docker', 'run', '--rm', 'test-image'], 
                                    capture_output=True, text=True, timeout=30)
              duration = time.time() - start_time
              print(f"   Run return code: {result.returncode}")
              print(f"   Run output: {result.stdout.strip()}")
              print(f"   Run duration: {duration:.2f} seconds")
              assert result.returncode == 0
              assert 'container started' in result.stdout
              
              print("All Docker tests passed!")

          if __name__ == "__main__":
              test_docker_environment()
          EOF

      - name: Run Docker environment test
        timeout-minutes: 10
        env:
          PYTHONUNBUFFERED: 1
        run: |
          echo "Docker containers before tests:"
          docker ps -a
          echo "Available Docker images:"
          docker images
          echo "Starting Docker environment test..."
          python test_docker.py

      - name: Report test results
        if: failure()
        run: |
          echo "::error::Slow tests failed! Check the logs above for details."
          echo "Consider reporting to appropriate channels (e.g., Slack)."
          # TODO: Add Slack notification or other reporting mechanism

      - name: Cleanup Docker resources
        if: always()
        run: |
          docker system prune -f
          docker volume prune -f

  api-tests:
    if: ${{ inputs.run_api_tests }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout inspect_ai repository
        uses: actions/checkout@v4
        with:
          repository: UKGovernmentBEIS/inspect_ai

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # Install inspect_ai with development dependencies for testing
          pip install -e ".[dev]"

      - name: Verify pytest options
        run: |
          echo "Checking available pytest options..."
          pytest --help | grep -E "(runslow|runapi)" || \
            echo "Custom pytest options not found, proceeding anyway..."

      - name: Show initial Docker state
        run: |
          echo "Docker images before tests:"
          docker images
          echo "Docker containers before tests:"
          docker ps -a

      - name: Run API tests
        timeout-minutes: 20
        run: |
          echo "Running API tests with --runapi flag..."
          pytest --runapi -v

      - name: Show final Docker state
        if: always()
        run: |
          echo "Docker images after tests:"
          docker images
          echo "Docker containers after tests:"
          docker ps -a

      - name: Report test results
        if: failure()
        run: |
          echo "::error::API tests failed! Check the logs above for details."
          echo "Consider reporting to appropriate channels (e.g., Slack)."
          # TODO: Add Slack notification or other reporting mechanism
